{"version":3,"file":"valleytpl.min.js","sources":["../src/utils/regexp-obj.js","../src/analyze-tag.js","../src/utils/type.js","../src/utils/sprintf.js","../src/init-tpl.js","../src/init-func-str.js","../src/utils/extend.js","../src/index.js","../src/hack-block.js","../src/remove-comments.js","../src/init-func.js","../src/plugins/datestr.js","../src/plugins/htmlspecialchars.js","../src/output/index.js"],"sourcesContent":["const tagOpen = '{{';\nconst tagClose = '}}';\n\nconst vRegStr = '([$\\\\w.\\\\[\\\\]]+)';//变量正则字符串\nconst filterRegExp = new RegExp(`${vRegStr}(?:\\\\|${vRegStr}(?::(.*))?)?`);\nconst inputRegExp = /\\s*(\"[^\"]+\"|[^,]+)\\s*/g;\n\nconst tagRegExp = new RegExp(`${tagOpen}([^{}]*?)${tagClose}`, 'g');\nconst varRegExp = /[_A-Za-z][\\w.]*/g;\n\nfunction analyzeFilter(input) {\n  if (!input) {\n    return null;\n  }\n  let res = input.match(filterRegExp);\n  if (!res) {\n    return null;\n  }\n  let obj = {};\n  obj.content = res && res[0];\n  obj.variable = res && res[1];\n  obj.filter = res && res[2];\n  obj.args = [];\n  if (res[3]) {\n    obj.args = res[3].match(inputRegExp).map(item => (item || '').trim());\n  }\n  return obj;\n}\n\n// for include tag\nconst includeRegExp = new RegExp(`${tagOpen}include\\\\s+([\\\\w.\\/]+)${tagClose}`, 'igm');\n\n// for extend tag\nconst extendRegExp = new RegExp(`${tagOpen}extends\\\\s+([\\\\w.\\/]+)${tagClose}`, 'igm');\n\n// for block tag\nconst blockOpen = `${tagOpen}block\\\\s+(\\\\w+)${tagClose}`;\nconst blockClose = `${tagOpen}/block${tagClose}`;\nconst blockRegExp = new RegExp(`${blockOpen}((?:.|[\\r\\n])*?)${blockClose}`, 'igm');\n\n// for hack block\nconst hackOpen = `${tagOpen}hack${tagClose}`;\nconst hackClose = `${tagOpen}/hack${tagClose}`;\nconst hackBlockRegExp = new RegExp(`${hackOpen}((?:.|[\\r\\n])*?)${hackClose}`, 'igm');\n\n// check variable\nconst keywordList = ['===', '==', '>', '>=', '<', '<=', '']\nconst judgeWords = '[\\\\+\\\\-\\\\*\\\\\\/%!\\\\?\\\\|\\\\^&~<>=,\\\\(\\\\)\\\\[\\\\];]+'\nconst stopWords = 'break|case|catch|continue|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|this|throw|try|typeof|var|void|while|with|abstract|boolean|byte|char|class|const|debugger|double|enum|export|extends|final|float|goto|implements|import|int|interface|long|native|package|private|protected|public|short|static|super|synchronized|throws|transient|volatile|as|each|let|const';\nconst stopwordRegExp = new RegExp(`\\\\s*\\\\b(?:${stopWords})\\\\b\\\\s*|\\\\s*${judgeWords}\\\\s*`, 'ig');\nfunction getVariableList(content) {\n  // console.log(content, content.split(stopwordRegExp))\n  return content.split(stopwordRegExp).filter(item => item && !item.match(/^\\d+$/) && !item.match(/^['\"].*['\"]$/) && !item.match(/^\\.+$/)).map(item => item.replace(/^\\.+|\\.+$/, '').split(/\\./g)[0]);\n}\n\nexport {\n  filterRegExp,\n  analyzeFilter,\n  hackBlockRegExp,\n  includeRegExp,\n  extendRegExp,\n  blockRegExp,\n  tagRegExp,\n  varRegExp,\n  getVariableList\n};\n","const tagRegExp = /\\{\\{([^{}]*?)\\}\\}/g;\n\n/**\n  tag info\n    {{ variable }}\n    {{if judgement}} ... {{elseif/elif judgement}} ... {{else}} ... {{/if}}\n    {{each list as value, key}} ... {{/each}}\n    {{for (let i = 0; i < list.length; i++)}} ... {{/for}}\n    {{ set variable value }}\n    {{ new variable value }}\n*/\n\nexport default function analyzeTag(tpl) {\n  let res;\n  let str;\n  let start = 0;\n  let mark = 0;\n  let content;\n  let tagInfo;\n  let tagName;\n  let tagArr;\n  let tags = [];\n  let tagObj = {};\n  while (res = tagRegExp.exec(tpl)) {\n    start = res.index;\n    content = res[0];\n    tagInfo = res[1];\n    if (mark < start) {\n      str = tpl.substring(mark, start);\n      str && tags.push({\n        type: 'string',\n        content: str\n      });\n    }\n    if (tagInfo) {\n      tagArr = tagInfo.split(/\\s+/);\n      tagName = tagArr.shift();\n      switch (tagName) {\n      case 'if':\n        tagObj = {\n          type: 'if',\n          content: tagArr.join(' ')\n          // content: tagArr\n        };\n        break;\n      case 'elseif':\n      case 'elif':\n        tagObj = {\n          type: 'elseif',\n          content: tagArr.join(' ')\n          // content: tagArr\n        };\n        break;\n      case 'else':\n        tagObj = {\n          type: 'else'\n        };\n        break;\n      case '/if':\n        tagObj = {\n          type: 'endif'\n        };\n        break;\n      case 'for':\n      case 'each':\n        tagObj = {\n          type: tagName,\n          content: tagArr.join(' ')\n          // content: tagArr\n        };\n        break;\n      case '/each':\n        tagObj = {\n          type: 'endeach'\n        };\n        break;\n      case '/for':\n        tagObj = {\n          type: 'endfor'\n        };\n        break;\n      case 'set':\n        tagObj = {\n          type: 'set',\n          content: tagArr.join(' ')\n        };\n        break;\n      // case 'new':\n      //   tagObj = {\n      //     type: 'new',\n      //     content: tagArr\n      //   };\n      //   break;\n      case 'debug':\n        break;\n      // case 'debug':\n      //   tagObj = {\n      //     type: 'debug',\n      //     content: tagInfo || '$data'\n      //   };\n      //   break;\n      // case 'js':\n      //   tagObj = {\n      //     type: 'js',\n      //     content: tagArr.join(' ')\n      //   };\n      //   break;\n      default:\n        tagObj = {\n          type: 'var',\n          content: tagInfo //{{}}包裹的部分都是变量\n        };\n      }\n      tags.push(tagObj);\n    }\n    mark = start + content.length;\n  }\n  if (mark < tpl.length) {\n    tags.push({\n      type: 'string',\n      content: tpl.substring(mark)\n    });\n  }\n  return tags;\n}\n","let class2type = {};\nlet toString = class2type.toString;\nlet getProto = Object.getPrototypeOf;\nlet hasOwn = class2type.hasOwnProperty;\nlet fnToString = hasOwn.toString;\nlet ObjectFunctionString = fnToString.call( Object );\n\n\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \").forEach(function(type){\n  class2type[\"[object \" + type + \"]\"] = type.toLowerCase();\n});\n\nexport function type(obj) {\n  if (obj == null) {\n    return obj + \"\";\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n      class2type[ toString.call(obj) ] || \"object\" : typeof obj;\n}\n\nexport function isFunction(input) {\n  return type(input) === 'function';\n}\n\nexport function isPlainObject(input) {\n  let proto;\n  let Ctor;\n\n  if ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n    return false;\n  }\n\n  proto = getProto( obj );\n\n  if ( !proto ) {\n    return true;\n  }\n\n  Ctor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n  return typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n}\n","import {\n  type\n} from './type';\n\nconst strRegExp = /%s/g;\nconst dstrRegExp = /%(\\d+)\\$s/g;\n\nexport default function sprintf() {\n  if (arguments.length < 2) {\n    throw 'Too few arguments';\n  }\n  var tpl = arguments[0];\n  var args, res, arr;\n  if (type(arguments[1]) === 'array') {\n    args = arguments[1];\n  } else {\n    args = Array.prototype.slice.call(arguments, 1);\n  }\n  if (args.length <= 0) {\n    throw 'Too few arguments';\n  }\n  res = tpl.replace(dstrRegExp, function($0, $1){\n    var index = $1 - 1;\n    if (args[index]) {\n      return args[index];\n    } else {\n      throw 'Tow few arguments';\n    }\n  });\n  arr = res.match(strRegExp) || [];\n  if (args.length === 1) {\n    return res.replace(strRegExp, args[0]);\n  } else if (arr.length > args.length) {\n    throw 'Too few arguments';\n  }\n  return res.replace(/%s/g, function(){\n    return args.shift();\n  });\n}\n\n","import sprintf from './utils/sprintf';\nimport {\n  analyzeFilter,\n  tagRegExp,\n  varRegExp,\n  getVariableList\n} from './utils/regexp-obj';\n\nconst stringTpl = 'vtmpArr.push(\\'%s\\');';\nconst variableTpl = 'vtmpArr.push(typeof %s === \"number\" ? %s : (%s || \"\"));';\nconst variableTpl2 = '(function(scope){vtmpArr.push(scope.%s(%s));}(self));';\nconst variableTpl3 = '(function(scope){var args=[%s];args.unshift(%s);vtmpArr.push(scope.%s.apply(scope, args));}(self));';\n\nconst varBlackList = 'break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile'.split(' ');\nconst checkObj = {\n  'eq': '==',\n  'ne': '!=',\n  'neq': '!=',\n  'gt': '>',\n  'gte': '>=',\n  'ge': '>=',\n  'lt': '<',\n  'lte': '<=',\n  'le': '<=',\n  'is even': '%2 == 0',\n  'is odd': '%2 == 1',\n  'is not even': '%2 != 0',\n  'is not odd': '%2 != 1',\n  'and': '&&',\n  'or': '||',\n  'not': '!',\n  'mod': '%',\n};\n\nconst vRegStr = '[$\\\\w]+';//变量正则字符串\nconst iRegStr = '(\"[^\"]+\"|[^,]+)';//输入正则字符串\n// const filterRegExp = new RegExp(`${vRegStr}\\|${vRegStr}(?:\\\\:${iRegStr}(?:,${iRegStr}))?`);\n\nfunction replaceJudgement(str) {\n  let keyRegExp = new RegExp(Object.keys(checkObj).join('\\\\s+|\\\\s+'), 'ig');\n  return str.replace(keyRegExp, function($0){\n    return checkObj[$0];\n  });\n}\n\nfunction isBlackVariable(key) {\n  return varBlackList.indexOf(key) >= 0;\n}\n\nexport default function initTplFunc(tags) {\n  let tpls = ['var vtmpArr = [];'];\n  let buffer = [];\n  // tpls.push('var __args_match_res = arguments.callee.toString().match(/function\\s+.*?\\((.*?)\\)/);');\n  // tpls.push('var __vargs = (__args_match_res && __args_match_res[0] || \"\").split(/\\s*,\\s*/);');\n  tags.forEach(tag => {\n    let content = (tag.content || '').trim();\n    let res;\n    switch (tag.type) {\n    case 'string':\n      tpls.push(sprintf(stringTpl, tag.content.replace(/[\\r\\n]+/g, '\\\\n').replace(/'/g, \"\\\\'\")));\n      break;\n    case 'var':\n      let filterObj = analyzeFilter(content);\n      let localVariable = (filterObj.variable || '').split(/[\\.\\[\\]]/)[0];\n      if (buffer.indexOf(localVariable) < 0) {\n        tpls.unshift(`var ${localVariable} = ${localVariable};`);\n        buffer.push(localVariable);\n      }\n      if (!filterObj.filter) {\n        tpls.push(sprintf(variableTpl, content));\n      } else if (filterObj.args.length <= 0) {\n        tpls.push(sprintf(variableTpl2, filterObj.filter, filterObj.variable));\n      } else {\n        let str = sprintf(variableTpl3, filterObj.args.join(','), filterObj.variable, filterObj.filter);\n        tpls.push(str);\n      }\n      break;\n    case 'if':\n    case 'for':\n    case 'elseif':\n      getVariableList(content).forEach(function(str){\n        if (buffer.indexOf(str) < 0) {\n          // tpls.unshift(`;if (${str} === undefined) { var ${str}; }`);\n          tpls.unshift(`var ${str} = ${str};`);\n          buffer.push(str);\n        }\n      });\n      if (!content.match(/^\\(.*\\)$/)) {\n        content = `(${content})`;\n      }\n      if (tag.type === 'elseif') {\n        tpls.push(`} else if ${content} {`);\n      } else {\n        tpls.push(`;${tag.type} ${content} {`);\n      }\n      break;\n    case 'else':\n      tpls.push('} else {');\n      break;\n    case 'endif':\n    case 'endfor':\n      tpls.push('}');\n      break;\n    case 'each':\n      // each语法: {{each list as value, key}}\n      let tmps = content.split(/\\s+as\\s+/);\n      if (tmps.length < 2) {\n        throw '[each] 缺少输入参数';\n      }\n      let eachName = tmps[0];\n      let eachInput = tmps[1].split(',');\n      let eachValue = (eachInput[0] || '').trim();\n      let eachKey = (eachInput[1] || '').trim();\n      // let forArr = `${tmps[0]}.forEach(function(${tmps[1]}){`;\n      let forObj;\n      if (eachKey) {\n        forObj = `Object.keys(${eachName}).forEach(function(${eachKey}){var ${eachValue} = ${eachName}[${eachKey}];`;\n      } else {\n        forObj = `Object.values(${eachName}).forEach(function(${eachValue}){`;\n      }\n      tpls.push(forObj);\n      break;\n    case 'endeach':\n      tpls.push('});');\n      break;\n    case 'set':\n      // set variable\n      let sets = content.split(/\\s+/);\n      let varStr;\n      if (sets.length < 2) {\n        throw '[set] 缺少输入参数';\n      }\n      if (sets[0].indexOf('#') === 0) {\n        varStr = sets[0].replace(/^#/, '');\n        tpls.push(`var ${varStr};`);\n      } else {\n        varStr = sets[0];\n        if (buffer.indexOf(varStr) < 0) {\n          tpls.unshift(`var ${varStr};`);\n          buffer.push(varStr);\n        }\n      }\n      tpls.push(`${varStr} = ${sets[1]};`);\n      break;\n    // case 'debug':\n    //   tpls.push(`;window.${content} = arguments;`);\n    //   break;\n    // case 'js':\n    //   tpls.push(`;${content};`);\n    //   break;\n    }\n  });\n  tpls.push('return vtmpArr.join(\"\");');\n  return tpls;\n}\n","function replaceHack(content, hackObj) {\n  let hackRegExp = new RegExp(`<<HACK_MARK_\\\\d+>>`, 'g');\n  content = content.replace(hackRegExp, $0 => {\n    return hackObj[$0].replace(/[\\r\\n]/g, '\\\\n').replace(/'/g, \"\\\\'\");\n  });\n  return content;\n}\n\nfunction initScope() {\n  let scopes = ['var $scope = {};'];\n  scopes.push('$scope.now = Date.now();');\n  scopes.push('var self = this;');\n  return scopes;\n}\n\nexport default function initFuncStr(tags, hackObj) {\n  let scopes = initScope();\n  let farr = scopes.concat(tags);\n  let funstr = farr.join('\\n');\n  funstr = replaceHack(funstr, hackObj);\n  return funstr;\n}\n","import {\n  type,\n  isFunction,\n  isPlainObject\n} from './type';\n\nexport default function extend() {\n  var options, name, src, copy, copyIsArray, clone,\n      target = arguments[ 0 ] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false;\n\n  if ( typeof target === \"boolean\" ) {\n    deep = target;\n\n    target = arguments[ i ] || {};\n    i++;\n  }\n\n  if ( typeof target !== \"object\" && !isFunction( target ) ) {\n    target = {};\n  }\n\n  if ( i === length ) {\n    target = this;\n    i--;\n  }\n\n  for ( ; i < length; i++ ) {\n\n    if ( ( options = arguments[ i ] ) != null ) {\n\n      for ( name in options ) {\n        src = target[ name ];\n        copy = options[ name ];\n\n        if ( target === copy ) {\n          continue;\n        }\n\n        if ( deep && copy && ( isPlainObject( copy ) ||\n          ( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && Array.isArray( src ) ? src : [];\n\n          } else {\n            clone = src && isPlainObject( src ) ? src : {};\n          }\n\n          target[ name ] = extend( deep, clone, copy );\n\n        // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n}\n","import removeComments from './remove-comments';\nimport hackBlock from './hack-block';\nimport analyzeTag from './analyze-tag';\nimport initTpl from './init-tpl';\nimport initFuncStr from './init-func-str';\nimport initFunc from './init-func';\nimport extend from './utils/extend';\n\nlet cacheObj = {};\n\nfunction ValleyTpl(tpl, data, scope) {\n  let res;\n\n  if (cacheObj[tpl] && ValleyTpl.useCache) {\n    // 命中缓存\n    res = cacheObj[tpl];\n  } else {\n    // 去掉注释\n    res = removeComments(tpl);\n\n    // 挂起页面中不需要解析的块\n    let hackObj = {};\n    res = hackBlock(res, hackObj);\n\n    // 解析标签\n    res = analyzeTag(res);\n\n    // 生成模板语言\n    res = initTpl(res);\n\n    // 生成模板函数\n    res = initFuncStr(res, hackObj);\n\n    if (ValleyTpl.useCache) {\n      cacheObj[tpl] = res;\n    }\n  }\n\n  if (!data) {\n    return res;\n  }\n\n  let keys = Object.keys(data);\n  let values = Object.values(data);\n\n  scope = scope ? extend({}, ValleyTpl.scope, scope) : ValleyTpl.scope;\n\n  // 生成模板函数\n  res = initFunc(res, keys);\n\n  // 执行模板函数\n  res = res.apply(scope, values);\n\n  return res;\n}\n\nValleyTpl.scope = {};\nValleyTpl.useCache = true;\n\n// 注册函数到全局范围\nValleyTpl.register = function(fname, func) {\n  this.scope[fname] = func;\n};\n\n// 取消全局注册的函数\nValleyTpl.unregister = function(fname) {\n  delete this.scope[fname];\n};\n\nexport default ValleyTpl;\n","import {\n  hackBlockRegExp\n} from './utils/regexp-obj';\n\nexport default function hackBlock(content, hackObj) {\n  let res;\n  let mark = 0;\n  return content.replace(hackBlockRegExp, function($0, $1){\n    let key = `<<HACK_MARK_${mark}>>`;\n    hackObj[key] = $1;\n    mark ++;\n    return key;\n  });\n}\n\nfunction replaceHack(tags, hackObj) {\n  let hackRegExp = new RegExp(`<<HACK_MARK_\\\\d+>>`, 'g');\n  content = content.replace(hackRegExp, $0 => {\n    return hackObj[$0].replace(/[\\r\\n]/g, '\\\\n').replace(/'/g, \"\\\\'\");\n  });\n  return content;\n}\n\n","/**\n * 去掉注释\n *    行注释：*** -> //\n *    块注释：{* ... *}\n *    input: tpl\n *    output: 去掉注释的tpl\n */\nexport default function removeComments(tpl) {\n  if (!tpl) {\n    return '';\n  }\n  // return tpl.split(/[\\r\\n]+/g).map(line => line.replace(/\\*\\*\\*.*$/, '')).join('\\n').replace(/\\{\\*(.|[\\r\\n])*?\\*\\}/, '').trim();\n  return tpl.replace(/\\*\\*\\*.*?(?:[\\r\\n]+|$)/g, '').replace(/\\{\\*(.|[\\r\\n])*?\\*\\}/g, '').trim();\n}\n\n","export default function initFunction(funstr, keys, hackObj) {\n  funstr = `try { ${funstr} } catch(e) { console.error(e); }`;\n  try {\n    return new Function(keys, funstr);\n  } catch(e) {\n    console.error(funstr);\n    console.error(e);\n  }\n}\n","const DefaultTPL = 'Y-M-D H:I:S';\n\nexport default function datestr(timestamp, tpl) {\n  let date;\n  if (typeof timestamp === 'string' && isNaN(timestamp)) {\n    tpl = timestamp;\n    timestamp = new Date();\n  }\n  if (!timestamp) {\n    date = new Date();\n  } else if (timestamp.toString().length === 10) {\n    date = new Date(timestamp * 1000);\n  } else {\n    date = new Date(timestamp);\n  }\n  tpl = tpl || DefaultTPL;\n  let month = date.getMonth() + 1;\n  let day = date.getDate();\n  let hour = date.getHours();\n  let minute = date.getMinutes();\n  let second = date.getSeconds();\n  let obj = {\n    'Y': date.getFullYear(),\n    'y': date.getYear(),\n    'M': month < 10 ? ('0' + month) : month,\n    'm': month,\n    'D': day < 10 ? ('0' + day) : day,\n    'd': day,\n    'H': hour < 10 ? ('0' + hour) : hour,\n    'h': hour,\n    'I': minute < 10 ? ('0' + minute) : minute,\n    'i': minute,\n    'S': second < 10 ? ('0' + second) : second,\n    's': second\n  };\n  return tpl.replace(/[YMDHISymdhis]/g, $0 => obj[$0]);\n}\n","const escapeHash = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '/': '&#x2f;'\n};\n\nconst escapeRegExp = new RegExp('[&<>\"\\']', 'igm')\n\nexport default function htmlspecialchars(str) {\n  return typeof str === 'string' ? str.replace(escapeRegExp, $0 => escapeHash[$0]) : str;\n}\n","import vtpl from '../index';\nimport datestr from '../plugins/datestr';\nimport htmlspecialchars from '../plugins/htmlspecialchars';\n\nvtpl.register('datestr', datestr);\nvtpl.register('htmlspecialchars', htmlspecialchars);\n\nexport default vtpl;\n"],"names":["filterRegExp","RegExp","vRegStr","inputRegExp","hackBlockRegExp","hackOpen","stopwordRegExp","tagRegExp","class2type","toString","getProto","Object","getPrototypeOf","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","call","type","obj","isPlainObject","input","proto","Ctor","constructor","split","forEach","toLowerCase","strRegExp","dstrRegExp","sprintf","arguments","length","args","res","arr","tpl","Array","prototype","slice","replace","$0","$1","index","match","shift","stringTpl","variableTpl","variableTpl2","variableTpl3","initTplFunc","tags","tpls","buffer","content","tag","trim","push","filterObj","variable","filter","map","item","analyzeFilter","localVariable","indexOf","unshift","str","join","tmps","eachName","eachInput","eachValue","eachKey","forObj","sets","varStr","initFuncStr","hackObj","funstr","scopes","initScope","concat","hackRegExp","replaceHack","extend","options","name","src","copy","copyIsArray","clone","target","i","deep","this","isArray","undefined","cacheObj","ValleyTpl","data","scope","useCache","initTpl","start","mark","tagInfo","tagName","tagArr","tagObj","exec","substring","analyzeTag","key","hackBlock","removeComments","keys","values","Function","e","error","initFunc","apply","register","fname","func","unregister","DefaultTPL","escapeHash","escapeRegExp","timestamp","date","isNaN","Date","month","getMonth","day","getDate","hour","getHours","minute","getMinutes","second","getSeconds","getFullYear","getYear","vtpl"],"mappings":"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"}